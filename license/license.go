package license

import (
	"encoding/json"
	"fmt"
	"github.com/hyperboloide/lk"
	"github.com/toolkits/file"
	"log"
	"time"
)

func GenLicense(day int) {
	// a base32 encoded private key generated by lkgen gen
	const privateKeyBase32 = "FD7YCAYBAEFXA22DN5XHIYLJNZSXEAP7QIAACAQBANIHKYQBBIAACAKEAH7YIAAAAAFP7AYFAEBP7BQAAAAP7GP7QIAWCBGNHH2WMESVKT5R564LJ3SVQGSSO3W6S6RXOMLI5PZAQJU463QTQWSJZ4M76QNZYUOI6SD3HLHWDJZ7N66DEXD6JMZWEF52QV2ZHE5JNH36M2MP2V24KY7SNUBQZQPPCBWGK2AEHQONXQKKSYCLPW4YWGLVAEYQERU2D3ML3WGSBQRS5RZ3EWGNBWF3DXU4U4FNGV4X7DRT265MNRIW3LVTHP3IY5DYKYPEZF5G7SFGYQAA===="

	// Here we use a struct that is marshalled to json, but ultimatly all you need is a []byte.
	doc := struct {
		End time.Time `json:"end"`
	}{
		time.Now().Add(time.Hour * 24 * time.Duration(day)),
	}

	// marshall the document to []bytes (this is the data that our license will contain).
	docBytes, err := json.Marshal(doc)
	if err != nil {
		log.Fatal(err)
	}

	// Unmarshal the private key
	privateKey, err := lk.PrivateKeyFromB32String(privateKeyBase32)
	if err != nil {
		log.Fatal(err)
	}

	// generate your license with the private key and the document
	license, err := lk.NewLicense(privateKey, docBytes)
	if err != nil {
		log.Fatal(err)

	}
	// the b32 representation of our license, this is what you give to your customer.
	licenseB32, err := license.ToB32String()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(licenseB32)
	file.WriteString(".license.dat", licenseB32)
}
